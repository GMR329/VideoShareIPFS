"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageCache = void 0;
const utils_1 = require("./utils");
class MessageCache {
    constructor(gossip, history) {
        this.msgs = new Map();
        this.peertx = new Map();
        this.history = [];
        for (let i = 0; i < history; i++) {
            this.history[i] = [];
        }
        this.gossip = gossip;
    }
    /**
     * Adds a message to the current window and the cache
     */
    async put(msg, msgIdStr) {
        this.msgs.set(msgIdStr, msg);
        const msgId = (0, utils_1.messageIdFromString)(msgIdStr);
        this.history[0].push({ msgId: msgId, topics: msg.topicIDs });
    }
    /**
     * Retrieves a message from the cache by its ID, if it is still present
     */
    get(msgId) {
        return this.msgs.get((0, utils_1.messageIdToString)(msgId));
    }
    /**
     * Retrieves a message from the cache by its ID, if it is present
     * for a specific peer.
     * Returns the message and the number of times the peer has requested the message
     */
    getForPeer(msgIdStr, p) {
        const msg = this.msgs.get(msgIdStr);
        if (!msg) {
            return [undefined, 0];
        }
        let peertx = this.peertx.get(msgIdStr);
        if (!peertx) {
            peertx = new Map();
            this.peertx.set(msgIdStr, peertx);
        }
        const count = (peertx.get(p) ?? 0) + 1;
        peertx.set(p, count);
        return [msg, count];
    }
    /**
     * Retrieves a list of message IDs for a given topic
     */
    getGossipIDs(topic) {
        const msgIds = [];
        for (let i = 0; i < this.gossip; i++) {
            this.history[i].forEach((entry) => {
                for (const t of entry.topics) {
                    if (t === topic) {
                        msgIds.push(entry.msgId);
                        break;
                    }
                }
            });
        }
        return msgIds;
    }
    /**
     * Shifts the current window, discarding messages older than this.history.length of the cache
     */
    shift() {
        const last = this.history[this.history.length - 1];
        last.forEach((entry) => {
            const msgIdStr = (0, utils_1.messageIdToString)(entry.msgId);
            this.msgs.delete(msgIdStr);
            this.peertx.delete(msgIdStr);
        });
        this.history.pop();
        this.history.unshift([]);
    }
}
exports.MessageCache = MessageCache;
