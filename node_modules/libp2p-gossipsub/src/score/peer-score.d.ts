/// <reference types="node" />
import { PeerScoreParams } from './peer-score-params';
import { PeerStats } from './peer-stats';
import { MessageDeliveries } from './message-deliveries';
import ConnectionManager from 'libp2p/src/connection-manager';
import { InMessage } from 'libp2p-interfaces/src/pubsub';
interface ScoreCacheEntry {
    /** The cached score, null if not cached */
    score: number | null;
    /** Unix timestamp in miliseconds, the time after which the cached score for a peer is no longer valid */
    cacheUntil: number;
}
export declare class PeerScore {
    /**
     * The score parameters
     */
    params: PeerScoreParams;
    /**
     * Per-peer stats for score calculation
     */
    peerStats: Map<string, PeerStats>;
    /**
     * IP colocation tracking; maps IP => set of peers.
     */
    peerIPs: Map<string, Set<string>>;
    /**
     * Cache score up to decayInterval if topic stats are unchanged.
     */
    scoreCache: Map<string, ScoreCacheEntry>;
    /**
     * Recent message delivery timing/participants
     */
    deliveryRecords: MessageDeliveries;
    _connectionManager: ConnectionManager;
    _backgroundInterval?: NodeJS.Timeout;
    constructor(params: PeerScoreParams, connectionManager: ConnectionManager);
    /**
     * Start PeerScore instance
     */
    start(): void;
    /**
     * Stop PeerScore instance
     */
    stop(): void;
    /**
     * Periodic maintenance
     */
    background(): void;
    /**
     * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.
     */
    _refreshScores(): void;
    /**
     * Return the score for a peer
     */
    score(id: string): number;
    /**
     * Apply a behavioural penalty to a peer
     */
    addPenalty(id: string, penalty: number): void;
    addPeer(id: string): void;
    removePeer(id: string): void;
    graft(id: string, topic: string): void;
    prune(id: string, topic: string): void;
    /**
     * @param {InMessage} message
     * @returns {Promise<void>}
     */
    validateMessage(msgIdStr: string): Promise<void>;
    deliverMessage(msg: InMessage, msgIdStr: string): Promise<void>;
    rejectMessage(msg: InMessage, msgIdStr: string, reason: string): Promise<void>;
    duplicateMessage(msg: InMessage, msgIdStr: string): Promise<void>;
    /**
     * Increments the "invalid message deliveries" counter for all scored topics the message is published in.
     */
    _markInvalidMessageDelivery(id: string, msg: InMessage): void;
    /**
     * Increments the "first message deliveries" counter for all scored topics the message is published in,
     * as well as the "mesh message deliveries" counter, if the peer is in the mesh for the topic.
     */
    _markFirstMessageDelivery(id: string, msg: InMessage): void;
    /**
     * Increments the "mesh message deliveries" counter for messages we've seen before,
     * as long the message was received within the P3 window.
     */
    _markDuplicateMessageDelivery(id: string, msg: InMessage, validatedTime?: number): void;
    /**
     * Gets the current IPs for a peer.
     */
    _getIPs(id: string): string[];
    /**
     * Adds tracking for the new IPs in the list, and removes tracking from the obsolete IPs.
     */
    _setIPs(id: string, newIPs: string[], oldIPs: string[]): void;
    /**
     * Removes an IP list from the tracking list for a peer.
     */
    _removeIPs(id: string, ips: string[]): void;
    /**
     * Update all peer IPs to currently open connections
     */
    _updateIPs(): void;
}
export {};
