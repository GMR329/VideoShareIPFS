/// <reference types="node" />
import Pubsub, { InMessage } from 'libp2p-interfaces/src/pubsub';
import { MessageCache } from './message-cache';
import { RPC, IRPC } from './message/rpc';
import { PeerScore, PeerScoreParams, PeerScoreThresholds } from './score';
import { IWantTracer } from './tracer';
import { AddrInfo, MessageIdFunction } from './interfaces';
import { SimpleTimeCache } from './utils/time-cache';
import { Debugger } from 'debug';
import Libp2p from 'libp2p';
import PeerStreams from 'libp2p-interfaces/src/pubsub/peer-streams';
import PeerId = require('peer-id');
export declare const multicodec: string;
export interface GossipInputOptions {
    emitSelf: boolean;
    canRelayMessage: boolean;
    gossipIncoming: boolean;
    fallbackToFloodsub: boolean;
    floodPublish: boolean;
    doPX: boolean;
    msgIdFn: MessageIdFunction;
    fastMsgIdFn: FastMsgIdFn;
    messageCache: MessageCache;
    globalSignaturePolicy: 'StrictSign' | 'StrictNoSign' | undefined;
    scoreParams: Partial<PeerScoreParams>;
    scoreThresholds: Partial<PeerScoreThresholds>;
    directPeers: AddrInfo[];
    /**
     * D sets the optimal degree for a Gossipsub topic mesh.
     */
    D: number;
    /**
     * Dlo sets the lower bound on the number of peers we keep in a Gossipsub topic mesh.
     */
    Dlo: number;
    /**
     * Dhi sets the upper bound on the number of peers we keep in a Gossipsub topic mesh.
     */
    Dhi: number;
    /**
     * Dscore affects how peers are selected when pruning a mesh due to over subscription.
     */
    Dscore: number;
    /**
     * Dout sets the quota for the number of outbound connections to maintain in a topic mesh.
     */
    Dout: number;
    /**
     * Dlazy affects how many peers we will emit gossip to at each heartbeat.
     */
    Dlazy: number;
    /**
     * heartbeatInterval is the time between heartbeats in milliseconds
     */
    heartbeatInterval: number;
    /**
     * fanoutTTL controls how long we keep track of the fanout state. If it's been
     * fanoutTTL milliseconds since we've published to a topic that we're not subscribed to,
     * we'll delete the fanout map for that topic.
     */
    fanoutTTL: number;
    /**
     * mcacheLength is the number of windows to retain full messages for IWANT responses
     */
    mcacheLength: number;
    /**
     * mcacheGossip is the number of windows to gossip about
     */
    mcacheGossip: number;
    /**
     * seenTTL is the number of milliseconds to retain message IDs in the seen cache
     */
    seenTTL: number;
}
interface GossipOptions extends GossipInputOptions {
    scoreParams: PeerScoreParams;
    scoreThresholds: PeerScoreThresholds;
}
interface AcceptFromWhitelistEntry {
    /** number of messages accepted since recomputing the peer's score */
    messagesAccepted: number;
    /** have to recompute score after this time */
    acceptUntil: number;
}
declare type FastMsgIdFn = (msg: InMessage) => string;
export default class Gossipsub extends Pubsub {
    peers: Map<string, PeerStreams>;
    /** Direct peers */
    direct: Set<string>;
    /** Cache of seen messages */
    seenCache: SimpleTimeCache<void>;
    /**
     * Map of peer id and AcceptRequestWhileListEntry
     */
    acceptFromWhitelist: Map<string, AcceptFromWhitelistEntry>;
    topics: Map<string, Set<string>>;
    /**
     * Map of topic meshes
     * topic => peer id set
     */
    mesh: Map<string, Set<string>>;
    /**
     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership
     * topic => peer id set
     */
    fanout: Map<string, Set<string>>;
    /**
     * Map of last publish time for fanout topics
     * topic => last publish time
     */
    lastpub: Map<string, number>;
    /**
     * Map of pending messages to gossip
     * peer id => control messages
     */
    gossip: Map<string, RPC.IControlIHave[]>;
    /**
     * Map of control messages
     * peer id => control message
     */
    control: Map<string, RPC.IControlMessage>;
    /**
     * Number of IHAVEs received from peer in the last heartbeat
     */
    peerhave: Map<string, number>;
    /** Number of messages we have asked from peer in the last heartbeat */
    iasked: Map<string, number>;
    /** Prune backoff map */
    backoff: Map<string, Map<string, number>>;
    /**
     * Connection direction cache, marks peers with outbound connections
     * peer id => direction
     */
    outbound: Map<string, boolean>;
    defaultMsgIdFn: MessageIdFunction;
    /**
     * A fast message id function used for internal message de-duplication
     */
    getFastMsgIdStr: FastMsgIdFn | undefined;
    /** Maps fast message-id to canonical message-id */
    fastMsgIdCache: SimpleTimeCache<string> | undefined;
    /**
     * A message cache that contains the messages for last few hearbeat ticks
     */
    messageCache: MessageCache;
    /** Peer score tracking */
    score: PeerScore;
    /**
     * Number of heartbeats since the beginning of time
     * This allows us to amortize some resource cleanup -- eg: backoff cleanup
     */
    heartbeatTicks: number;
    /**
     * Tracks IHAVE/IWANT promises broken by peers
     */
    gossipTracer: IWantTracer;
    multicodecs: string[];
    started: boolean;
    peerId: PeerId;
    subscriptions: Set<string>;
    _libp2p: Libp2p;
    _options: GossipOptions;
    _directPeerInitial: NodeJS.Timeout;
    log: Debugger & {
        err: Debugger;
    };
    emit: (event: string | symbol, ...args: any[]) => boolean;
    static multicodec: string;
    _heartbeatTimer: {
        _intervalId: NodeJS.Timeout | undefined;
        runPeriodically(fn: () => void, period: number): void;
        cancel(): void;
    } | null;
    /**
     * @param {Libp2p} libp2p
     * @param {Object} [options]
     * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed
     * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed
     * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped
     * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub
     * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers
     * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.
     * @param {Object} [options.messageCache] override the default MessageCache
     * @param {FastMsgIdFn} [options.fastMsgIdFn] fast message id function
     * @param {string} [options.globalSignaturePolicy = "StrictSign"] signing policy to apply across all messages
     * @param {Object} [options.scoreParams] peer score parameters
     * @param {Object} [options.scoreThresholds] peer score thresholds
     * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections
     * @constructor
     */
    constructor(libp2p: Libp2p, options?: Partial<GossipInputOptions>);
    /**
     * Decode a Uint8Array into an RPC object
     * Overrided to use an extended protocol-specific protobuf decoder
     * @override
     */
    _decodeRpc(bytes: Uint8Array): RPC;
    /**
     * Encode an RPC object into a Uint8Array
     * Overrided to use an extended protocol-specific protobuf encoder
     * @override
     */
    _encodeRpc(rpc: RPC): Uint8Array;
    /**
     * Add a peer to the router
     * @override
     */
    _addPeer(peerId: PeerId, protocol: string): PeerStreams;
    /**
     * Removes a peer from the router
     * @override
     */
    _removePeer(peerId: PeerId): PeerStreams | undefined;
    /**
     * Handles an rpc request from a peer
     *
     * @override
     */
    _processRpc(id: string, peerStreams: PeerStreams, rpc: RPC): Promise<boolean>;
    /**
     * Handles an rpc control message from a peer
     */
    _processRpcControlMessage(id: string, controlMsg: RPC.IControlMessage): Promise<void>;
    /**
     * Process incoming message,
     * emitting locally and forwarding on to relevant floodsub and gossipsub peers
     * @override
     */
    _processRpcMessage(msg: InMessage): Promise<void>;
    /**
     * Whether to accept a message from a peer
     * @override
     */
    _acceptFrom(id: string): boolean;
    /**
     * Validate incoming message
     * @override
     */
    validate(msg: InMessage): Promise<void>;
    /**
     * Handles IHAVE messages
     */
    _handleIHave(id: string, ihave: RPC.IControlIHave[]): RPC.IControlIWant[];
    /**
     * Handles IWANT messages
     * Returns messages to send back to peer
     */
    _handleIWant(id: string, iwant: RPC.IControlIWant[]): RPC.IMessage[];
    /**
     * Handles Graft messages
     */
    _handleGraft(id: string, graft: RPC.IControlGraft[]): Promise<RPC.IControlPrune[]>;
    /**
     * Handles Prune messages
     */
    _handlePrune(id: string, prune: RPC.IControlPrune[]): void;
    /**
     * Add standard backoff log for a peer in a topic
     */
    _addBackoff(id: string, topic: string): void;
    /**
     * Add backoff expiry interval for a peer in a topic
     * @param interval backoff duration in milliseconds
     */
    _doAddBackoff(id: string, topic: string, interval: number): void;
    /**
     * Apply penalties from broken IHAVE/IWANT promises
     */
    _applyIwantPenalties(): void;
    /**
     * Clear expired backoff expiries
     */
    _clearBackoff(): void;
    /**
     * Maybe reconnect to direct peers
     */
    _directConnect(): void;
    /**
     * Maybe attempt connection given signed peer records
     */
    _pxConnect(peers: RPC.IPeerInfo[]): Promise<void>;
    /**
     * Mounts the gossipsub protocol onto the libp2p node and sends our
     * our subscriptions to every peer connected
     * @override
     */
    start(): Promise<void>;
    /**
     * Unmounts the gossipsub protocol and shuts down every connection
     * @override
     */
    stop(): Promise<void>;
    /**
     * Connect to a peer using the gossipsub protocol
     */
    _connect(id: string): void;
    /**
     * Subscribes to a topic
     * @override
     */
    subscribe(topic: string): void;
    /**
     * Unsubscribe to a topic
     * @override
     */
    unsubscribe(topic: string): void;
    /**
     * Join topic
     */
    join(topic: string): void;
    /**
     * Leave topic
     */
    leave(topic: string): void;
    /**
     * Return the canonical message-id of a message as a string
     *
     * If a fast message-id is set: Try 1. the application cache 2. the fast cache 3. `getMsgId()`
     * If a fast message-id is NOT set: Just `getMsgId()`
     */
    getCanonicalMsgIdStr(msg: InMessage): Promise<string>;
    /**
     * An application should override this function to return its cached message id string without computing it.
     * Return undefined if message id is not found.
     * If a fast message id function is not defined, this function is ignored.
     */
    getCachedMsgIdStr(msg: InMessage): string | undefined;
    /**
     * Publish messages
     *
     * @override
     */
    _publish(msg: InMessage): Promise<void>;
    /**
     * Sends a GRAFT message to a peer
     */
    _sendGraft(id: string, topic: string): void;
    /**
     * Sends a PRUNE message to a peer
     */
    _sendPrune(id: string, topic: string): Promise<void>;
    /**
     * @override
     */
    _sendRpc(id: string, outRpc: IRPC): void;
    _piggybackControl(id: string, outRpc: IRPC, ctrl: RPC.IControlMessage): void;
    _piggybackGossip(id: string, outRpc: IRPC, ihave: RPC.IControlIHave[]): void;
    /**
     * Send graft and prune messages
     * @param tograft peer id => topic[]
     * @param toprune peer id => topic[]
     */
    _sendGraftPrune(tograft: Map<string, string[]>, toprune: Map<string, string[]>, noPX: Map<string, boolean>): Promise<void>;
    /**
     * Emits gossip to peers in a particular topic
     * @param exclude peers to exclude
     */
    _emitGossip(topic: string, exclude: Set<string>): void;
    /**
     * Flush gossip and control messages
     */
    _flush(): void;
    /**
     * Adds new IHAVE messages to pending gossip
     */
    _pushGossip(id: string, controlIHaveMsgs: RPC.IControlIHave): void;
    /**
     * Returns the current time in milliseconds
     */
    _now(): number;
    /**
     * Make a PRUNE control message for a peer in a topic
     */
    _makePrune(id: string, topic: string, doPX: boolean): Promise<RPC.IControlPrune>;
    /**
     * Maintains the mesh and fanout maps in gossipsub.
     */
    _heartbeat(): void;
    /**
     * Given a topic, returns up to count peers subscribed to that topic
     * that pass an optional filter function
     *
     * @param filter a function to filter acceptable peers
     */
    private getGossipPeers;
}
export {};
